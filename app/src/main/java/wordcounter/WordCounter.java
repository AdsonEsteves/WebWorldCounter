/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package wordcounter;

import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import javax.swing.AbstractAction;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.WindowConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;

import com.fasterxml.jackson.databind.ObjectMapper;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

public class WordCounter {
    // static String saveFolder = "C:\\Users\\shina\\Desktop\\";
    static String saveFolder = "";
    static JFrame frame = new JFrame("Word Coocurrence");
    static JPanel mainPanel = new JPanel();
    static JPanel searchPanel = new JPanel();
    static JPanel resultsPanel = new JPanel();
    static JTextField searchText = new JTextField("Celulares em 2022");
    static JTextArea display = new JTextArea(25, 65);
    static JLabel label = new JLabel("");
    static List<String> usedLinks = new ArrayList<>();
    static List<String> stopWords = new ArrayList<>();

    public static void main(String[] args) throws Exception {
        loadstopWords();
        screen();
    }

    public static void screen() {

        JPanel middlePanel = new JPanel();
        middlePanel.setBorder(new TitledBorder(new EtchedBorder(), "Display Area"));

        // create the middle panel components

        display.setEditable(false); // set textArea non-editable
        JScrollPane scroll = new JScrollPane(display);
        scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        JButton botaoBusca = new JButton(new AbstractAction("Buscar") {
            @Override
            public void actionPerformed(ActionEvent e) {

                new Thread(() -> {
                    try {
                        search();
                    } catch (Exception e1) {
                        e1.printStackTrace();
                    }
                }).start();
            }
        });

        // Add Textarea in to middle panel
        middlePanel.add(scroll);

        searchPanel.add(searchText);
        searchPanel.add(botaoBusca);
        searchPanel.add(label);

        resultsPanel.add(middlePanel);

        mainPanel.add(searchPanel);
        mainPanel.add(resultsPanel);

        frame.add(mainPanel);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        frame.setPreferredSize(new Dimension(800, 600));
        mainPanel.setPreferredSize(new Dimension(800, 600));
        searchPanel.setPreferredSize(new Dimension(800, 40));
        resultsPanel.setPreferredSize(new Dimension(800, 500));
        // display.setPreferredSize(new Dimension(730, 400));
        searchText.setPreferredSize(new Dimension(300, 20));

        resultsPanel.setLocation(0, 100);
        reload();
    }

    public static void reload() {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                mainPanel.revalidate();
                mainPanel.repaint();
                frame.pack();
            }
        });
    }

    public static void addTextToDisplay(String txt) {
        SwingUtilities.invokeLater(() -> {
            display.setText(display.getText() + txt);
            // reload();
        });
    }

    public static void changeDisplayText(String txt) {
        SwingUtilities.invokeLater(() -> {
            display.setText(txt);
        });
    }

    public static void search() throws Exception {
        // Cada palavra tem uma lista de sites a que pertence e o número de vezes que é
        // citada naquele site
        Map<String, Map<String, Integer>> wordmap = new HashMap<>();

        SwingUtilities.invokeLater(() -> {
            label.setText("Baixando");
        });

        List<String> links = google_results(searchText.getText(), 10);

        usedLinks.clear();

        wordmap = returnLinksOnPage(wordmap, links, 1, stopWords);
        wordmap = sortByComparator(wordmap, false);
        // new SearchWorker(wordmap).execute();
        printWordCoocurence(wordmap);
    }

    private static List<String> loadstopWords() {

        try (Stream<Path> paths = Files.walk(Paths.get("../stopwords"))) {
            paths.filter(Files::isRegularFile).forEach(WordCounter::convert);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return stopWords;
    }

    public static void convert(Path name) {
        try {
            String content = new String(Files.readAllBytes(Paths.get(name.toUri()))).replaceAll("[\t\r\n]", "");
            stopWords.addAll(Arrays.asList(new ObjectMapper().readValue(content, String[].class)));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static Map<String, Map<String, Integer>> returnLinksOnPage(Map<String, Map<String, Integer>> wordmap,
            List<String> links, int nivel, List<String> stopWords) {
        // List<String> links = new ArrayList<>();

        // Para cada link que é recebido por parametro
        // 1 - É baixado o seu HTML
        // 2 - Verificado se o nível atual é 0
        // 3 - Se não : é Buscado todos os links
        // 3.1 - Link são mandados por parametro recursivamente
        // 3.2 - Recebe todas as palavras daquele link
        // 4 - Conta todas as palavras
        // 5 - Retorna a lista de palavras

        for (String URL : links) {
            usedLinks.add(URL);
            if (URL.contains("google.com"))
                continue;
            System.out.println("\n\n Baixando o html: " + URL);
            changeDisplayText("\n\n Baixando o html: " + URL);
            try {
                String html = getHTML2(URL);
                // System.out.println("\n\nParse html" + html);
                if (nivel > 0) {
                    List<String> allMatches = new ArrayList<String>();
                    Matcher m = Pattern.compile("(?<=href=\")https:\\/\\/.*?(?=\")").matcher(html);
                    while (m.find()) {
                        if (!allMatches.contains(m.group()) && !usedLinks.contains(m.group())) {
                            // allMatches.add(m.group().replaceAll("(\")|(>)|( )", ""));
                            allMatches.add(m.group());
                            System.out.println(m.group());
                        }
                    }
                    wordmap = returnLinksOnPage(wordmap, allMatches, nivel - 1, stopWords);
                }
                html = Jsoup.parse(html).text();
                html = html.replaceAll("[^\\p{L} ]", "").toLowerCase();
                String[] todasAsPalavrasDoSite = html.split(" ");

                System.out.println("Contando palavras");
                addTextToDisplay("\nContando palavras");
                SwingUtilities.invokeLater(() -> {
                    label.setText("Contando Palavras");
                    // reload();
                });
                for (int i = 0; i < todasAsPalavrasDoSite.length; i++) {
                    if (todasAsPalavrasDoSite[i].length() < 4 || stopWords.contains(todasAsPalavrasDoSite[i])) {
                        continue;
                    }
                    if (wordmap.containsKey(todasAsPalavrasDoSite[i])) {
                        Map<String, Integer> wordData = wordmap.get(todasAsPalavrasDoSite[i]);
                        if (wordData.containsKey(URL)) {
                            int count = wordData.get(URL);
                            wordData.put(URL, count + 1);
                        } else {
                            wordData.put(URL, 1);
                        }
                        wordmap.put(todasAsPalavrasDoSite[i], wordData);
                    } else {
                        Map<String, Integer> wordData = new HashMap<>();
                        wordData.put(URL, 1);
                        wordmap.put(todasAsPalavrasDoSite[i], wordData);
                    }
                }

            } catch (Exception e) {
                System.out.println(e);
                continue;
            }
        }

        return wordmap;
    }

    public static List<String> google_results(String keyword, int no_of_results) throws Exception {
        List<String> searchedLinks = new ArrayList<>();

        // Replace space by + in the keyword as in the google search url
        keyword = keyword.replace(" ", "+");
        String query = URLEncoder.encode(keyword, "UTF8");
        String url = "https://www.google.com/search?q=" + query + "&num=" + String.valueOf(no_of_results);
        // Connect to the url and obain HTML response
        Document doc = Jsoup.connect(url).userAgent("Mozilla").timeout(5000).get();
        // System.out.println(doc.body().html());
        // parsing HTML after examining DOM
        Elements els = doc.select("a[href]");
        for (Element el : els) {
            // Print title, site and abstract
            System.out.println(el.text());
            String temp = el.attr("href");
            if (temp.startsWith("/url?q=")) {
                // use regex to get domain name
                String link = temp.replace("/url?q=", "").replaceAll("&sa=(.+)", "");
                if (!searchedLinks.contains(link)) {
                    searchedLinks.add(link);
                    System.out.println(link);
                }
            }
        }
        return searchedLinks;
    }

    public static String getHTML2(String URL) throws IOException {
        String userAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/A.B     (KHTML, like Gecko) Chrome/X.Y.Z.W Safari/A.B.";
        Connection connectionTest = Jsoup.connect(URL).timeout(10000).userAgent(userAgent);
        // Document doc = Jsoup.parse(new URL(URL).openStream(), "ISO-8859-1", URL);
        Document doc = Jsoup.parse(new String(connectionTest.execute().bodyAsBytes(), "UTF-8"));
        doc.charset(Charset.forName("UTF-8"));
        // Document doc = Jsoup.connect(URL).timeout(10000).get();
        return doc.body().html();
    }

    private static Map<String, Map<String, Integer>> sortByComparator(Map<String, Map<String, Integer>> unsortMap,
            final boolean order) {

        List<Entry<String, Map<String, Integer>>> list = new LinkedList<Entry<String, Map<String, Integer>>>(
                unsortMap.entrySet());

        // Sorting the list based on values
        Collections.sort(list, new Comparator<Entry<String, Map<String, Integer>>>() {
            public int compare(Entry<String, Map<String, Integer>> o1, Entry<String, Map<String, Integer>> o2) {
                if (order) {
                    return Integer.compare(o1.getValue().size(), o2.getValue().size());
                } else {
                    return Integer.compare(o2.getValue().size(), o1.getValue().size());

                }
            }
        });

        // Maintaining insertion order with the help of LinkedList
        Map<String, Map<String, Integer>> sortedMap = new LinkedHashMap<String, Map<String, Integer>>();
        for (Entry<String, Map<String, Integer>> entry : list) {
            sortedMap.put(entry.getKey(), entry.getValue());
        }

        return sortedMap;
    }

    private static void printWordCoocurence(Map<String, Map<String, Integer>> wordmap) {
        File printTxT = new File(saveFolder + "results.txt");
        List<String> fileLines = new ArrayList<>();
        // SwingUtilities.invokeLater(() -> {
        StringBuilder sb = new StringBuilder();
        changeDisplayText("\n\n\n Resultados:");
        for (Entry<String, Map<String, Integer>> entry : wordmap.entrySet()) {
            String word = entry.getKey();
            Map<String, Integer> wordData = entry.getValue();
            sb.append(word + ": " + wordData.size() + "\n");
            for (Entry<String, Integer> entry2 : wordData.entrySet()) {
                String URL = entry2.getKey();
                int count = entry2.getValue();
                sb.append(URL + "-> " + count + "\n");
            }
            // addTextToDisplay();
        }
        fileLines.add(sb.toString());
        // addTextToDisplay("\n" + sb.toString());

        try {
            givenWritingStringToFile_whenUsingPrintWriter_thenCorrect(printTxT, fileLines);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        addTextToDisplay("acabou");
        // });

        try {
            System.out.println("Escrito arquivo em " + printTxT.getCanonicalPath());
        } catch (IOException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
    }

    public static void givenWritingStringToFile_whenUsingPrintWriter_thenCorrect(File fileName, List<String> lines)
            throws IOException {
        // if (!fileName.exists()) {
        // fileName.getParentFile().mkdirs();
        // }
        FileWriter fileWriter = new FileWriter(fileName);
        PrintWriter printWriter = new PrintWriter(fileWriter);
        for (String string : lines) {
            printWriter.println(string);
        }
        printWriter.close();
    }

    static class SearchWorker extends SwingWorker<Integer, String> {
        Map<String, Map<String, Integer>> wordmap;

        public SearchWorker(Map<String, Map<String, Integer>> wordmap) {
            this.wordmap = wordmap;
        }

        protected Integer doInBackground() throws Exception {
            try {
                publish("\n\n\n Resultados:\n");
                for (Entry<String, Map<String, Integer>> entry : wordmap.entrySet()) {
                    StringBuilder sb = new StringBuilder();
                    String word = entry.getKey();
                    Map<String, Integer> wordData = entry.getValue();
                    sb.append(word + ": " + wordData.size() + "\n");
                    for (Entry<String, Integer> entry2 : wordData.entrySet()) {
                        String URL = entry2.getKey();
                        int count = entry2.getValue();
                        sb.append(URL + "-> " + count + "\n");
                    }
                    publish("\n" + sb.toString());
                }
                publish("\n\nacabou");
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println(e.getCause());
            }
            return 0;
        }

        @Override
        protected void process(List<String> chunks) {
            for (String string : chunks) {
                display.append(string);
            }
        }

        protected void done() {
            try {
                label.setText("Finalizado");
                System.out.println("FINALIZOU");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
