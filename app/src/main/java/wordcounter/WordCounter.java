/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package wordcounter;

import java.awt.Color;
import java.awt.Desktop;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Stream;

import javax.swing.AbstractAction;
import javax.swing.BoxLayout;
import javax.swing.JButton;
import javax.swing.JFrame;
import javax.swing.JLabel;
import javax.swing.JPanel;
import javax.swing.JScrollPane;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.ScrollPaneConstants;
import javax.swing.SwingUtilities;
import javax.swing.SwingWorker;
import javax.swing.WindowConstants;
import javax.swing.border.EtchedBorder;
import javax.swing.border.TitledBorder;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.gargoylesoftware.htmlunit.BrowserVersion;
import com.gargoylesoftware.htmlunit.NicelyResynchronizingAjaxController;
import com.gargoylesoftware.htmlunit.WebClient;
import com.gargoylesoftware.htmlunit.html.HtmlAnchor;
import com.gargoylesoftware.htmlunit.html.HtmlPage;
import com.gargoylesoftware.htmlunit.javascript.JavaScriptEngine;

import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;

public class WordCounter {
    // static String saveFolder = "C:\\Users\\shina\\Desktop\\";
    static String saveFolder = "";
    static JFrame frame = new JFrame("Word Coocurrence");
    static JPanel mainPanel = new JPanel();
    static JPanel searchPanel = new JPanel();
    static JPanel resultsPanel = new JPanel();
    static JTextField searchText = new JTextField("Celulares em 2022");
    static JTextArea display = new JTextArea(25, 65);
    static JLabel label = new JLabel("");
    static JLabel textLabel = new JLabel();
    static List<String> usedLinks = new ArrayList<>();
    static List<String> stopWords = new ArrayList<>();
    static JButton openFinalFile = new JButton("Abrir Resultados");
    static JLabel mesesLabel = new JLabel("Periodos em meses");
    static JTextField mesesField = new JTextField("1");
    static JLabel periodosLabel = new JLabel("Numero de Periodos");
    static JTextField periodosField = new JTextField("1");
    static JLabel resultadosLabel = new JLabel("Resultados por período");
    static JTextField resultadosField = new JTextField("10");
    static JLabel niveisLabel = new JLabel("Niveis de página a mais");
    static JTextField niveisField = new JTextField("0");
    static JLabel twLabel = new JLabel("tw");
    static JTextField twField = new JTextField("0.05");

    public static void main(String[] args) throws Exception {
        loadstopWords();
        screen();

        // TODO
        // Capturar as seguintes variaveis pelo usuários:
        // periodos(meses),
        // numerodevezes,
        // numeroderesultados.
        // Opcao: Pegar apenas os de hoje
        // Pega todas as paginas dentro do período estipulado pelo numero de vezes
        // decidido
        // Calcula DoD e DoV para cada período para cada palavra

    }

    public static void screen() {

        JPanel middlePanel = new JPanel();
        middlePanel.setBorder(new TitledBorder(new EtchedBorder(), "Options"));
        middlePanel.setLayout(new BoxLayout(middlePanel, BoxLayout.Y_AXIS));

        JPanel optionsPanel = new JPanel();

        mesesField.setPreferredSize(new Dimension(30, 20));

        periodosField.setPreferredSize(new Dimension(30, 20));

        resultadosField.setPreferredSize(new Dimension(30, 20));
        niveisField.setPreferredSize(new Dimension(30, 20));

        // JTextPane textPane = new JTextPane();
        // textPane.setText("");
        // textPane.setPreferredSize(new Dimension(70, 10));

        JPanel textPane = new JPanel();
        textPane.setLayout(new BoxLayout(textPane, BoxLayout.LINE_AXIS));
        textLabel.setText("Fortes Sinais");
        textLabel.setPreferredSize(new Dimension(70, 100));
        textPane.add(textLabel);

        openFinalFile.setBackground(new Color(255, 255, 255));
        openFinalFile.setForeground(new Color(0, 0, 0));
        openFinalFile.setEnabled(false);

        // create the middle panel components

        display.setEditable(false); // set textArea non-editable
        JScrollPane scroll = new JScrollPane(display);
        scroll.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        JButton botaoBusca = new JButton(new AbstractAction("Buscar") {
            @Override
            public void actionPerformed(ActionEvent e) {

                new Thread(() -> {
                    try {
                        search();
                    } catch (Exception e1) {
                        e1.printStackTrace();
                    }
                }).start();
            }
        });

        // Add Textarea in to middle panel
        // middlePanel.add(scroll);
        optionsPanel.add(mesesLabel);
        optionsPanel.add(mesesField);
        optionsPanel.add(periodosLabel);
        optionsPanel.add(periodosField);
        optionsPanel.add(resultadosLabel);
        optionsPanel.add(resultadosField);
        optionsPanel.add(niveisLabel);
        optionsPanel.add(niveisField);
        optionsPanel.add(twLabel);
        optionsPanel.add(twField);
        middlePanel.add(optionsPanel);
        middlePanel.add(textPane);

        searchPanel.add(searchText);
        searchPanel.add(botaoBusca);
        searchPanel.add(label);

        resultsPanel.add(middlePanel);

        mainPanel.add(searchPanel);
        mainPanel.add(resultsPanel);
        mainPanel.add(openFinalFile);

        frame.add(mainPanel);
        frame.setVisible(true);
        frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);

        frame.setPreferredSize(new Dimension(800, 300));
        mainPanel.setPreferredSize(new Dimension(800, 600));
        searchPanel.setPreferredSize(new Dimension(800, 40));
        resultsPanel.setPreferredSize(new Dimension(800, 160));
        middlePanel.setPreferredSize(new Dimension(750, 150));
        // display.setPreferredSize(new Dimension(730, 400));
        searchText.setPreferredSize(new Dimension(300, 20));

        resultsPanel.setLocation(0, 100);
        frame.pack();
        frame.setLocationRelativeTo(null);
        reload();
    }

    public static void reload() {
        SwingUtilities.invokeLater(new Runnable() {
            public void run() {
                mainPanel.revalidate();
                mainPanel.repaint();
                frame.pack();
            }
        });
    }

    public static void addTextToDisplay(String txt) {
        SwingUtilities.invokeLater(() -> {
            textLabel.setText(textLabel.getText() + txt);
            // reload();
        });
    }

    public static void changeDisplayText(String txt) {
        SwingUtilities.invokeLater(() -> {
            textLabel.setText(txt);
        });
    }

    public static void search() throws Exception {
        // Cada palavra tem uma lista de sites a que pertence e o número de vezes que é
        // citada naquele site
        Map<String, Map<String, Integer>> wordmap = new HashMap<>();

        SwingUtilities.invokeLater(() -> {
            label.setText("Baixando");
        });

        Map<Integer, List<String>> mappedLinks = new LinkedHashMap<>();
        Map<Integer, Map<String, Map<String, Integer>>> mappedwords = new LinkedHashMap<>();

        LocalDateTime today = LocalDateTime.now();
        DateTimeFormatter formmat1 = DateTimeFormatter.ofPattern("MM/dd/yyyy", Locale.ENGLISH);
        LocalDateTime newDate = today;

        for (int i = 0; i < Integer.parseInt(periodosField.getText()); i++) {

            wordmap.clear();
            LocalDateTime last6 = newDate.minusMonths(Integer.parseInt(mesesField.getText()));

            // String timePeriod = formmat1.format(newDate) + " to " +
            // formmat1.format(last6);
            System.out.println("Baixando de " + formmat1.format(last6) + " a " + formmat1.format(newDate));
            List<String> links = google_results(searchText.getText(), Integer.parseInt(resultadosField.getText()),
                    formmat1.format(last6), formmat1.format(newDate));

            mappedLinks.put(i, links);

            usedLinks.clear();
            wordmap = returnLinksOnPage(wordmap, links, Integer.parseInt(niveisField.getText()), stopWords);
            wordmap = sortByComparator(wordmap, false);
            mappedwords.put(i, new HashMap<String, Map<String, Integer>>(wordmap));
            // new SearchWorker(wordmap).execute();
            newDate = last6;

        }
        CalculateFrequency.calculate(mappedwords, mappedLinks, Double.parseDouble(twField.getText()));
        printWordCoocurence(wordmap);
    }

    private static List<String> loadstopWords() {

        try (Stream<Path> paths = Files.walk(Paths.get("./stopwords"))) {
            paths.filter(Files::isRegularFile).forEach(WordCounter::convert);
        } catch (Exception e) {
            e.printStackTrace();
        }

        return stopWords;
    }

    public static void convert(Path name) {
        try {
            String content = new String(Files.readAllBytes(Paths.get(name.toUri()))).replaceAll("[\t\r\n]", "");
            stopWords.addAll(Arrays.asList(new ObjectMapper().readValue(content, String[].class)));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static Map<String, Map<String, Integer>> returnLinksOnPage(Map<String, Map<String, Integer>> wordmap,
            List<String> links, int nivel, List<String> stopWords) {
        // List<String> links = new ArrayList<>();

        // Para cada link que é recebido por parametro
        // 1 - É baixado o seu HTML
        // 2 - Verificado se o nível atual é 0
        // 3 - Se não : é Buscado todos os links
        // 3.1 - Link são mandados por parametro recursivamente
        // 3.2 - Recebe todas as palavras daquele link
        // 4 - Conta todas as palavras
        // 5 - Retorna a lista de palavras

        for (String URL : links) {
            usedLinks.add(URL);
            if (URL.contains("google.com"))
                continue;
            // System.out.println("\n\n Baixando o html: " + URL);
            changeDisplayText("\n\n Baixando o html: " + URL);
            try {
                String html = getHTML2(URL);
                // System.out.println("\n\nParse html" + html);
                if (nivel > 0) {
                    List<String> allMatches = new ArrayList<String>();
                    Matcher m = Pattern.compile("(?<=href=\")https:\\/\\/.*?(?=\")").matcher(html);
                    while (m.find()) {
                        if (!allMatches.contains(m.group()) && !usedLinks.contains(m.group())) {
                            // allMatches.add(m.group().replaceAll("(\")|(>)|( )", ""));
                            allMatches.add(m.group());
                            // System.out.println(m.group());
                        }
                    }
                    wordmap = returnLinksOnPage(wordmap, allMatches, nivel - 1, stopWords);
                }
                html = Jsoup.parse(html).text();
                html = html.replaceAll("[^\\p{L} ]", "").replaceAll("[,.]", "").toLowerCase();
                String[] todasAsPalavrasDoSite = html.split(" ");

                // System.out.println("Contando palavras");
                addTextToDisplay("\nContando palavras");
                SwingUtilities.invokeLater(() -> {
                    label.setText("Contando Palavras");
                    // reload();
                });
                for (int i = 0; i < todasAsPalavrasDoSite.length; i++) {
                    if (todasAsPalavrasDoSite[i].length() < 4 || stopWords.contains(todasAsPalavrasDoSite[i])) {
                        continue;
                    }
                    if (wordmap.containsKey(todasAsPalavrasDoSite[i])) {
                        Map<String, Integer> wordData = wordmap.get(todasAsPalavrasDoSite[i]);
                        if (wordData.containsKey(URL)) {
                            int count = wordData.get(URL);
                            wordData.put(URL, count + 1);
                        } else {
                            wordData.put(URL, 1);
                        }
                        wordmap.put(todasAsPalavrasDoSite[i], wordData);
                    } else {
                        Map<String, Integer> wordData = new HashMap<>();
                        wordData.put(URL, 1);
                        wordmap.put(todasAsPalavrasDoSite[i], wordData);
                    }
                }

            } catch (Exception e) {
                System.out.println(e);
                continue;
            }
        }

        return wordmap;
    }

    public static List<String> google_results(String keyword, int no_of_results, String oldDate, String newDate)
            throws Exception {
        List<String> searchedLinks = new ArrayList<>();

        // Replace space by + in the keyword as in the google search url
        // keyword = keyword.replace(" ", "+");
        String query = URLEncoder.encode(keyword, "UTF8");
        boolean hasDate = (oldDate == null || oldDate == "" || newDate == null || newDate == "");
        String date_query = hasDate ? ""
                : "&tbs=" + URLEncoder.encode("cdr:1,cd_min:" + oldDate + ",cd_max:" + newDate, "UTF8");
        String url = "https://www.google.com/search?q=" + query + date_query + "&num=" + String.valueOf(no_of_results);
        // Connect to the url and obain HTML response
        WebClient wc = new WebClient(BrowserVersion.FIREFOX);
        wc.getOptions().setThrowExceptionOnScriptError(false);
        wc.setJavaScriptTimeout(10000);
        wc.getOptions().setJavaScriptEnabled(true);
        wc.setAjaxController(new NicelyResynchronizingAjaxController());
        wc.getOptions().setTimeout(10000);
        wc.waitForBackgroundJavaScript(3000);
        JavaScriptEngine engine = (JavaScriptEngine) wc.getJavaScriptEngine();
        engine.holdPosponedActions();
        HtmlPage page = (HtmlPage) wc.getPage(url);
        List<Object> body = page.getByXPath("//div[@class='g']//a");
        System.out.println(url);
        for (Iterator iter = body.iterator(); iter.hasNext();) {
            HtmlAnchor anchor = (HtmlAnchor) iter.next();
            if (isSkipLink(anchor)) {
                continue;
            }
            // System.out.println(anchor.getHrefAttribute());
            searchedLinks.add(anchor.getHrefAttribute());
        }
        return searchedLinks;
    }

    /**
     * Decide if this link has to be processed.
     *
     * @param anchor link
     * @return true if link has to be omitted, false if is to be processed
     */
    private static boolean isSkipLink(HtmlAnchor anchor) {

        return anchor.getHrefAttribute().startsWith("/") || anchor.getHrefAttribute().startsWith("#")
                || anchor.getHrefAttribute().indexOf("/search?q=cache:") > 0;
    }

    public static String getHTML2(String URL) throws IOException {
        String userAgent = "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/A.B     (KHTML, like Gecko) Chrome/X.Y.Z.W Safari/A.B.";
        Connection connectionTest = Jsoup.connect(URL).timeout(10000).userAgent(userAgent);
        // Document doc = Jsoup.parse(new URL(URL).openStream(), "ISO-8859-1", URL);
        Document doc = Jsoup.parse(new String(connectionTest.execute().bodyAsBytes(), "UTF-8"));
        doc.charset(Charset.forName("UTF-8"));
        // Document doc = Jsoup.connect(URL).timeout(10000).get();
        return doc.body().html();
    }

    private static Map<String, Map<String, Integer>> sortByComparator(Map<String, Map<String, Integer>> unsortMap,
            final boolean order) {

        List<Entry<String, Map<String, Integer>>> list = new LinkedList<Entry<String, Map<String, Integer>>>(
                unsortMap.entrySet());

        // Sorting the list based on values
        Collections.sort(list, new Comparator<Entry<String, Map<String, Integer>>>() {
            public int compare(Entry<String, Map<String, Integer>> o1, Entry<String, Map<String, Integer>> o2) {
                if (order) {
                    return Integer.compare(o1.getValue().size(), o2.getValue().size());
                } else {
                    return Integer.compare(o2.getValue().size(), o1.getValue().size());

                }
            }
        });

        // Maintaining insertion order with the help of LinkedList
        Map<String, Map<String, Integer>> sortedMap = new LinkedHashMap<String, Map<String, Integer>>();
        for (Entry<String, Map<String, Integer>> entry : list) {
            sortedMap.put(entry.getKey(), entry.getValue());
        }

        return sortedMap;
    }

    private static void printWordCoocurence(Map<String, Map<String, Integer>> wordmap) {
        File printTxT = new File(saveFolder + "results.txt");
        List<String> fileLines = new ArrayList<>();
        // SwingUtilities.invokeLater(() -> {
        StringBuilder sb = new StringBuilder();
        changeDisplayText("\n\n\n Resultados:");
        for (Entry<String, Map<String, Integer>> entry : wordmap.entrySet()) {
            String word = entry.getKey();
            Map<String, Integer> wordData = entry.getValue();
            sb.append(word + ": " + wordData.size() + "\n");
            for (Entry<String, Integer> entry2 : wordData.entrySet()) {
                String URL = entry2.getKey();
                int count = entry2.getValue();
                sb.append(URL + "-> " + count + "\n");
            }
        }
        fileLines.add(sb.toString());

        try {
            givenWritingStringToFile_whenUsingPrintWriter_thenCorrect(printTxT, fileLines);
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }

        addTextToDisplay("acabou");

        try {
            System.out.println("Escrito arquivo em " + printTxT.getCanonicalPath());
            openFinalFile.setAction(new AbstractAction("Abrir Resultados") {

                @Override
                public void actionPerformed(ActionEvent e) {
                    try {
                        Desktop.getDesktop().edit(printTxT);
                    } catch (IOException e1) {
                        // TODO Auto-generated catch block
                        e1.printStackTrace();
                    }
                }

            });
            openFinalFile.setEnabled(true);
        } catch (IOException e1) {
            // TODO Auto-generated catch block
            e1.printStackTrace();
        }
    }

    public static void givenWritingStringToFile_whenUsingPrintWriter_thenCorrect(File fileName, List<String> lines)
            throws IOException {
        // if (!fileName.exists()) {
        // fileName.getParentFile().mkdirs();
        // }
        FileWriter fileWriter = new FileWriter(fileName);
        PrintWriter printWriter = new PrintWriter(fileWriter);
        for (String string : lines) {
            printWriter.println(string);
        }
        printWriter.close();
    }

    static class SearchWorker extends SwingWorker<Integer, String> {
        Map<String, Map<String, Integer>> wordmap;

        public SearchWorker(Map<String, Map<String, Integer>> wordmap) {
            this.wordmap = wordmap;
        }

        protected Integer doInBackground() throws Exception {
            try {
                publish("\n\n\n Resultados:\n");
                for (Entry<String, Map<String, Integer>> entry : wordmap.entrySet()) {
                    StringBuilder sb = new StringBuilder();
                    String word = entry.getKey();
                    Map<String, Integer> wordData = entry.getValue();
                    sb.append(word + ": " + wordData.size() + "\n");
                    for (Entry<String, Integer> entry2 : wordData.entrySet()) {
                        String URL = entry2.getKey();
                        int count = entry2.getValue();
                        sb.append(URL + "-> " + count + "\n");
                    }
                    publish("\n" + sb.toString());
                }
                publish("\n\nacabou");
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println(e.getCause());
            }
            return 0;
        }

        @Override
        protected void process(List<String> chunks) {
            for (String string : chunks) {
                display.append(string);
            }
        }

        protected void done() {
            try {
                label.setText("Finalizado");
                System.out.println("FINALIZOU");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
